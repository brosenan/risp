initSidebarItems({"enum":[["CompilationError",""],["RispValue",""],["Rule",""]],"fn":[["compile","Compiler"],["read","Reader The function `read` implements a reader, converting a string into an s-expression, represented by `risp::RispValue`."]],"struct":[["BasicStaticContext","A static context that defines globals and macros. It contains no locals. `use risp::*; let mut ctx = BasicStaticContext::new(); ctx.define_global(String::from(\"foo\"), RispValue::Int(2)); ctx.define_macro(String::from(\"m\"), Box::new(|x| Ok(x))); assert_eq!(ctx.get_global(&String::from(\"foo\")), Some(RispValue::Int(2))); assert_eq!(ctx.is_local(&String::from(\"foo\")), false); let m = ctx.get_macro(&String::from(\"m\")).unwrap();`"],["DerivedStaticContext","A derived static context extends a base context, and possibly adds new local symbols. Its lifetime parameter means its base context must outlive it. `use risp::*; let mut base = BasicStaticContext::new(); base.define_global(String::from(\"foo\"), RispValue::Int(2)); base.define_macro(String::from(\"m\"), Box::new(|x| Ok(x))); let mut derived = DerivedStaticContext::new(&base); derived.add_local(String::from(\"bar\")); assert_eq!(derived.get_global(&String::from(\"foo\")).unwrap(), RispValue::Int(2)); let m = derived.get_macro(&String::from(\"m\")).unwrap(); assert_eq!(derived.is_local(&String::from(\"bar\")), true); assert_eq!(derived.is_local(&String::from(\"baz\")), false);`"],["RispRefIter","An iterator for s-expressions. Does not consume the underlying list, and provides immutable references to the items."]],"trait":[["StaticContext","This trait represents the state of compilation, defining what symbols (global, local and macros) are defiend, and in the cases of globals and macros, with which values."]]});